# #5. 댓글 / 답글 기능 구현하기
# project blog

---

## 개요

블로그 글을 쓸 때, 다른 사람의 피드백을 수용하는 것이 중요하다. 나 혼자 정리하고 공부한 내용 중 잘못 알고 있는 내용이 있다면 복잡하고 귀찮은 인증과정을 거치지 않고 쉽게 댓글을 작성할 수 있는 기능을 구현해야겠다고 생각했다. 

---

## 요구 사항 분석

내가 원하는 기능들을 최대한 나열해서 적어보고, 하나씩 하나씩 구현해보기로 했다. 이 글에서 **답글**은 댓글에 대한 댓글의 의마하는 용어로 사용했다.

1. 댓글, 답글을 작성할 때 작성닉네임 + 비밀번호를 사용자로부터 입력받는다. 이 때 입력된 비밀번호는 댓글 삭제 시 사용된다.
2. 특수문자 / 자릿수를 제한한다.
3. admin이 작성한 댓글은 작성닉네임 색을 다르게 표시한다.
4. admin이 전체 댓글들을 관리할 수 있도록 댓글을 모아서 보고 지울 수 있도록 한다.
5. 답글은, 답글이 달린 댓글이 삭제되면 함께 삭제되게 한다.
6. 게시글이 지워지면 관련 댓글, 답글들이 모두 지워지도록 한다.

---

## 1번 로직

* 댓글, 답글을 작성할 때 작성닉네임 + 비밀번호를 사용자로부터 입력받는다. 이 때 입력된 비밀번호는 댓글 삭제 시 사용된다.

댓글 및 답글을 저장하기 위해 comment, reply 테이블을 추가했다. 닉네임/비밀번호 입력 창을 프론트엔드에서 구현해보자.

![img](http://www.choigonyok.com/api/assets/33-1.png)

reply는 댓글창과 답글창이 한 번에 열리지 않고 동기적으로 열릴 수 있도록 하기 위해 만든 useState이다.

reply가 0이면 기본 댓글 입력창이 밑에 표시되고, 사용자가 댓글의 이름을 누르면 해당 댓글 아래에 답글 입력창이 표시되면서 reply를 1로 만들게된다.

그럼 맨 아래의 디폴트로 표시되던 기본 댓글 입력창은 사라지고, 사용자의 닉네임 밑에 답글 창이 나타나게 된다.

nowComment, nowID, nowPW는 모두 e.target.value를 받아서 상태를 업데이트하는 useState이다.

commentHandler, commentIDHandler, commentPWHandler 모두 위의 useState들을 업데이트하는 핸들러이며, 사용자가 입력을 다 하고 POST 버튼을 클릭하면 클릭이벤트가 발생해 commentSendHandler가 호출된다.

![img](http://www.choigonyok.com/api/assets/33-2.png)

이 commentSendHandler는 서버에 comData 데이터와 함께 PUT API 요청을 보낸다. comData는 CommentData를 의미하면서 지은 변수명인데 의미가 좀 모호한 것 같다. refactoring시 수정이 필요해 보인다.

![img](http://www.choigonyok.com/api/assets/33-3.png)

comData는 nowComment, nowID, nowPW useState가 변할 때마다 useEffect 훅을 통해 재정의된다.

```js
postid = props.id
```

이 코드는 부모 컴포넌트인 Postpage.js에서 댓글이 작성된 게시글의 id를 가져와 postid 변수에 저장한다.

댓글을 디비에 저장할 때 모든 포스트의 댓글을 하나의 comment, reply 테이블에서 관리하기 떄문에 

1. 특정 게시글에 접근할 때 해당 포스트에 맞는 댓글들을 가져올 수 있어야 해서 댓글들을 그룹화 하기 위해
2. 게시글이 삭제될 경우 해당 게시글의 id를 기준으로 안에 있던 댓글, 답글들까지 한 번에 삭제할 수 있게 하기 위해

이런 이유로 필요하다.

---

## 2번 로직

* 특수문자 / 자릿수를 제한한다.

특수문자는 이전 글에서 언급했던 것처럼, DB상 ' 심볼을 데이터로 활용할 수 없었기 때문에 요구사항에 추가했었고, 자릿수 제한은 무분별한 댓글을 막기 위해 제한을 두기 위함이었다.

> ' 심볼 DB 저장 불가 이슈는 이후 리팩토링 과정에서 해결되었고, 그 과정은 BLOG #4 글에서 확인할 수 있다.

자릿수 제한은 nowComment, nowID, nowPW를 각 핸들러에서 초기화할 때 조건문으로 처리했다.

댓글 작성 패스워드를 예시로 들면,

![img](http://www.choigonyok.com/api/assets/33-4.png)

이런 식으로 일정 길이가 넘어가면 사용자에게 alert를 보내는 방식을 이용했다. 추가적으로 댓글 패스워드는 길이뿐만 아니라, 숫자로만 이루어졌는지 등의 조금 더 복잡한 유효성 검사가 필요했는데, 이 부분은 서버에서 로직을 구현했다.

이외에도,

1. 댓글 본문, 닉네임, 패스워드 중 입력이 빈 항목이 있으면 피드백
2. 본문에는 quote가 있으면 디비에 저장할 때 오류가 발생하기 때문에 피드백

두 가지를 추가적으로 구현해야 했다.

### Golang regexp package

* 패스워드 숫자인지 확인하기

![img](http://www.choigonyok.com/api/assets/33-5.png)

go에서는 기본 내장 패키지에서 regexp라는 정규표현식 패키지를 제공한다. regexp는 regular expression, 말그대로 정규표현식이다.

여기서 "^[0-9]+$" 는 적어도 하나 이상의 0~9로 이루어졌는지를 체크하게된다.

컴파일러 강의에서 배운 정규표현식이 이렇게 패스워드 유효성 검사에서 유용하게 쓰일 줄 몰랐다.

go의 regexp 패키지에서 ^ 심볼은 시작지점을 가리킨다. 예를 들어서

        "^ABC"

라고 되어있으면 뒤가 얼마나 길든 뭐가 오든말든 어쩄든 맨 앞에는 ABC가 꼭 있어야한다는 의미이다.

반대로 $ 심볼은 종료지점을 의미한다. 예로

        "ABC$"

라고 되어있으면 앞에 뭐가 오든 얼마나 길게 오든 상관없고 마지막은 ABC로 끝나야 한다는 걸 의미한다.

이제 다시 "^[0-9]+$"를 보면, 이 정규표현식이 숫자로만 이루어진 모든 길이의 수를 의미하는 걸 확인할 수 있다. 길이는 프론트엔드에서 먼저 체크를 했기 때문에 길이 상관없이 이렇게 숫자로만 이루어졌는지 유효성 검사를 수행할 수 있게 된다.

* 댓글 본문, 닉네임, 패스워드 중 입력이 빈 항목이 있으면 피드백

![img](http://www.choigonyok.com/api/assets/33-6.png)

이건 ^ 뒤에 바로 $가 오니까, 시작하자마자 끝난다는 의미이다. 즉 아무 것도 없는 empty 상태를 표현하는 정규표현식이다.

* 본문에는 quote가 있으면 디비에 저장할 때 오류가 발생하기 때문에 피드백

![img](http://www.choigonyok.com/api/assets/33-7.png)

본문과 닉네임에 quote가 있는지 확인하고 있으면 StatusBadRequest(400)상태코드를 응답한다. 지금 보니까 PW는 위에서 정규표현식으로 유효성 검사를 했기 때문에 굳이 여기서 안적었어도 됐는데 적혀있다. 리팩토링할 때 수정해야겠다.

---

## 3번 로직

* admin이 작성한 댓글은 작성닉네임 색을 다르게 표시한다.

이를 위해서 댓글 POST 요청을 서버가 받을 때 쿠키도 함께 전송받도록 하고, comment, reply 테이블에 isadmin이라는 컬럼을 추가했다.

이 컬럼은 댓글이 admin에 의해 작성되었는지 아닌지를 1 또는 0으로 저장하고, 이후에 프론트엔드에서 이 isadmin 값을 보고 색을 다르게 표현할 수 있게 했다.

![img](http://www.choigonyok.com/api/assets/33-8.png)

admin 쿠키의 여부로 IsAdmin의 값을 초기화해서 댓글을 DB에 저장할 때 isadmin column에 함께 저장되도록 구현했다.

![img](http://www.choigonyok.com/api/assets/33-9.png)

---

## 4번 로직

* admin이 전체 댓글들을 관리할 수 있도록 댓글을 모아서 보고 지울 수 있도록 한다.

전체 댓글에 대한 삭제권한은 post의 작성 / 수정 / 삭제처럼 admin 사용자인 나에게만 있기 때문에 admin cookie를 확인하도록 구현했다.

댓글을 삭제할 일이 있다면 내가 작성한 댓글보다는 타인이 작성한 댓글만 보고 관리하는 게 편할 것 같아서 내가 작성한 댓글은 comments 관리 페이지에 표시되지 않도록 구현했다.

---

## 5번 로직

* 답글은, 답글이 달린 댓글이 삭제되면 함께 삭제되게 한다.

삭제를 위한 UX는 사용자가 댓글 본문 위에 커서를 올리면 우측에 x버튼이 표시되도록 했다.

![img](http://www.choigonyok.com/api/assets/33-10.png)

X 버튼이 클릭되면 pw 입력 창이 표시된다. 
 
![img](http://www.choigonyok.com/api/assets/33-11.png)

삭제 기능을 위해 db에 저장된 pw와 사용자가 입력한 pw를 비교해야하는데, 

![img](http://www.choigonyok.com/api/assets/33-12.png)

CheckPasswordHandler를 통해서 POST요청을 보낸다. 

url의 쿼리로 들어있는 comid는 해당 댓글의 id이고, inputpw는 사용자가 delete 버튼을 눌렀을 당시의 pw칸에 입력한 값을 전송한다.

이 pw는 댓글 하나만을 위한 1회성 pw이기도 하고 중요한 정보가 아니어서 보안에 크게 신경쓰지 않고 url의 쿼리로 전송되도록 했다.

setPasswordComment 와 setIsFinished는 각각 pw입력창을 닫기 위한 것과, comments 리렌더링을 통해 지워진 댓글/답글을 업데이트한 결과를 리렌더링하기 위한 useState이다.

이렇게 전송된 comment id와 input password는 서버로 가서 해당 comment id에 맞는 comment password를 가져오고, 서버에서 입력값과 실제값을 비교한다.

입력값이 올바른 패스워드로 확인되면 서버는 우선 해당 댓글에 달린 모든 답글 레코드들을 지우고나서, 댓글 레코드를 삭제한다.

---

## 6번 로직

* 게시글이 지워지면 관련 댓글, 답글들이 모두 지워지도록 한다.

원래 구현했었던 서버의 postDelete 핸들러에 로직을 추가해준다.

![img](http://www.choigonyok.com/api/assets/33-13.png)