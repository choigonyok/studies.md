#  #6. AWS에 배포하기
# project blog

---

## 개요

블로그 프로젝트를 마무리하고, 실서비스로 배포하기 위해 AWS 클라우드 컴퓨팅 플랫폼을 이용했다. 이 글은 리액트를 AWS에 배포하는 과정에 대해 설명한 글이다. 

---

## 인스턴스 생성

### 로그인

AWS에 접속하면 우측 상단에 "콘솔에 로그인" 버튼이 있다. 클릭하면 로그인 페이지가 나오는데 아이디가 있으면 로그인하고, 없다면 회원가입 후 로그인한다. 루트 사용자로 로그인하면 되는데,

![img](http://www.choigonyok.com/api/assets/34-1.png)

IAM 사용자는 루트 계정에서 파생된 서브 계정이라고 생각하면 된다.

루트 게정에서 IAM 사용자를 생성해서 접근 권한(읽기/쓰기 등)을 부여해줄 수 있다. 보안을 위해 IAM 사용자를 통해 진행하는 게 좋다고 하는데, 목적이 우선 배포과정을 경험하는데 있으므로 편리하게 루트 사용자로 접속해준다.

접속하면 왼쪽 위에 검색 창이 있는데, EC2 서비스를 검색해 들어간다.

![img](http://www.choigonyok.com/api/assets/34-2.png)

"인스턴스 시작" 버튼을 누르고, "이름 및 태그" 섹션에는 인스턴스의 이름을 설정해준다.

### AMI 설정
![img](http://www.choigonyok.com/api/assets/34-3.png)

밑의 "애플리케이션 및 이미지" 섹션에서는 AMI를 설정할 수 있다. AMI는 AWS에서 제공하는 다양한 버전과 종류의 OS 이미지이다.

나는 이전에 Ubuntu를 SSH 원격 접속으로 간단히 사용해 본 경험이 있어 Ubuntu로 OS를 선택했다.

바로 밑에 있는 Amazon Machine Image(AMI)에서 바로 내가 만들 가상의 인스턴스(서버/PC)의 스펙을 정할 수 있다.
SSD/HDD 등의 볼륨 타입이나 용량, 버전 등의 이미지를 정할 수 있다.

AWS에서는 처음 가입하면 가입일 기준 1년간 프리티어 계정으로 사용된다.

프리티어 계정은 AWS의 일부 서비스를 무료로 이용할 수 있다.

프리티어는 EC2 서비스에서 t2.micro 인스턴스를 이용할 수 있는데, 

![img](http://www.choigonyok.com/api/assets/34-4.png)

cpu 코어 수, 메모리 용량 및 시간 당 요금을 확인할 수 있다.

프리티어 사용가능이라고 표시되어 있는 것만 무료로 사용 가능하니 조심하자! 아니면 나도 모르게 몇 백만원이 청구되는 일이 생길지 모른다.

프리티어라고 무제한으로 t2.micro가 무료인 것은 아니고, EC2에서는 1달 최대 750시간의 t2.micro 인스턴스 사용을 제공한다. t2.micro 인스턴스 3개를 만들어도 한 달 동안 합쳐서 750시간 미만으로 쓰면 요금이 청구되지 않는 시스템이다.

### 키페어 생성 및 설정

그 다음으로는 키페어 섹션이다. 인스턴스를 생성하고, 해당 인스턴스에 접근할 때 이 키 페어를 통해서 접근할 수 있는 권한을 인증받게 된다.

![img](http://www.choigonyok.com/api/assets/34-5.png)

키 페어 생성을 누르면 이름을 입력할 수 있다. 이름은 원하는 키페어 이름으로 설정하고, 유형은 RSA로 설정한다.

.pem과 .ppk 중 하나를 선택해야하는데, PuTTY나 OpenSSH 중 접속할 때 무엇을 접속할지에 따라 선택해주면 된다. 나는 맥OS의 터미널로 SSH 접속을 할 예정이라 .pem 키로 설정했다.

### 보안그룹 설정

다음 보안그룹 섹션에서는 나중에 보안그룹 설정을 따로 해줄 것이기 때문에 "보안 그룹 생성"만 선택하고 넘어가자.

### 스토리지 설정

다음은 스토리지 설정인데, t2.micro라 메모리가 1GB밖에 안되는데, SSD라도 프리티어 꽉 차게 30GB로 알뜰히 사용해주자.

스토리지도 마찬가지로 프리티어는 1달에 30GiB까지 지원해준다. 디폴트르 스토리지는 8GiB로 설정되어있는데, 나는 인스턴스 하나에 모든 서비스 전체를 배포할 것이기 때문에, 30GiB로 꽉 채웠다.

밑의 "고급 세부 정보" 탭은 건드리지 않고 DEFAULT로 두고 이제 인스턴스 시작 버튼을 누른다.

### 생성 확인

![img](http://www.choigonyok.com/api/assets/34-6.png)

"인스턴스" 탭에 가보면 이처럼 새로운 인스턴스가 생성된 걸 확인할 수 있다. 인스턴스 상태는 바로 켜지는 게 아니라 "초기화" 상태를 거쳐 "실행 중" 상태로 변하는데 시간이 일부 소요된다. 마치 실제 데스크탑을 켜면 부팅 시간이 소요되듯이 말이다.

---

## 보안그룹 생성

아까 보안그룹에서 그냥 넘어갔는데, 이제 보안그룹을 생성하고 재연결해주어야 한다. 물론 인스턴스 생성시에 보안그룹을 바로 생성해서 적용할 수도 있다.

![img](http://www.choigonyok.com/api/assets/34-7.png)

왼쪽 탭에보면 "네트워크 및 보안" 탭의 하위 항목으로 "보안 그룹"이 있다. "보안 그룹 생성"을 누르면 보안그룹을 생성할 수 있는데, 

![img](http://www.choigonyok.com/api/assets/34-8.png)

보안그룹의 이름과 설명을 적어주고, VPC를 설정해준다.

VPC는 가상의 네트워크라고 보면 되는데, 보안그룹 설정은 **해당 네트워크(VPC) 안에서 적용될 보안 규칙**을 설정하는 것이다.

예를 들어, 인스턴스를 두 개 생성해서 하나엔 백엔드, 다른 하나엔 프런트엔드를 배포했다고 가정하자. 서로 다른 ip를 가진 두 서버가 서로 API등으로 **직접적인** 통신을 하기 위해서는 서로 같은 네트워크 범위 안에 존재해야한다.

물론 스위치 등의 L3장치를 이용하면 스위치를 통한 간접적 통신이 가능하지만 어쨌든 이런 가상의 네트워크 대역을 VPC라고 한다.

밑에는 인바운드/아웃바운드 규칙이 있다. 인바운드는 이 인스턴스로 들어오는 것에 대한 보안 규칙을 설정하는 것이고, 아웃바운드는 이 인스턴스에서 나가는 것에 대한 보안 규칙을 설정하는 것이다.

우리는 SSH를 통해 이 인스턴스에 접근해야하고, 또 이후엔 HTTP를 통해서, 또 SSL인증을 받은 이후엔 HTTPS를 통해서 접근해야하기 때문에, 인바운드 규칙을 생성하고 편집해준다.

![img](http://www.choigonyok.com/api/assets/34-9.png)

"규칙 추가"를 눌러서 SSH를 지정하고, 소스는 이미지와 다르게 내 IP로 설정해준다. 또 HTTP도 지정하고 소스는 Anywhere-IPv4로 설정한다.

SSH로 이 VPC의 인스턴스에 접근할 때는 지금 현재 IP로만 접근 가능하도록, HTTP로 접근할 떄는 모든 IP 버전4로부터 접근할 수 있도록 설정하는 것이다.

그래야 어떤 곳에서 어떤 기기로 접근하든지 HTTP를 통해 이 인스턴스에 배포될 어플리케이션에 사용자들이 접근할 수 있게 되는 것이다.

아웃바운드 규칙은 설정하지 않고 이렇게 보안 규칙을 저장한다.

인스턴스의 보안 그룹을 변경하고 싶다면, "인스턴스"탭으로 가서 작업 -> 보안 -> 보안그룹 변경을 누르면 기존 연결되어있던 보안그룹을 삭제하고 새로운 보안그룹을 연결할 수 있다.

보안그룹을 수정하려면 "네트워크 및 보안"의 "보안그룹" 탭으로 이동해서 작업 -> 인바운드 규칙 편집을 누르면 수정이 가능하다.

보안 그룹과 관련해서 한 가지 주의해야할 점은 보안 그룹의 소스를 내 ip로 설정했을 때 이후 접속이 안되는 안될 때가 있다는 것이다. 

이후에 설명하겠지만 SSH를 통해 pem키와 사용자 이름, 퍼블릭 ip를 잘 설정했음에도 접속이 되지않는다면, 현재 로컬의 ip주소가 변하지 않았는지 확인해보아야한다.

로컬 컴퓨터의 ip는 전원이 꺼졌다 켜질 때마다 새롭게 할당된다. 이는 고정된 ip를 사용하는 게 아니라 라우터에서 할당해준 사설ip 대역이기 때문에 그렇다. 그래서 잘 입력했는데 접속이 안된다면, 인바운드 규칙 편집에 들어가서 소스를 내 ip주소로 다시 한 번 설정해보기를 권한다.

보안그룹을 삭제하고 싶다면, 보안그룹에 연결되어있는 인스턴스를 먼저 해제한 후에 삭제가 가능하다.

---

## EIP 생성 및 연결

EIP는 탄력적 IP(Elastic IP)을 줄임말이다.

처음 인스턴스를 생성하면 

![img](http://www.choigonyok.com/api/assets/34-10.png)

이런 퍼블릭 주소가 할당된다.

이 긴 주소는 외우기도 어려울 뿐더러, 인스턴스가 중단, 일시정지될 때마다 새롭게 할당되는 주소이다. 이게 무슨 의미냐면 사용자들이 내가 배포한 서비스에 접근하기 위해서 매번 다른 주소를 입력해야한다는 것이다.

정확한 예시는 아니지만, 네이버 홈페이지에 접속하기 위해서 오늘은 www.naver.com, 내일은 www.naver123.com에 접속해야하는 상황과 비슷하다.

이런 일을 막기 위해서 고정된 ip주소가 필요하고, 이 역할을 해주는 것이 바로 **탄력적 ip주소**이다.

![img](http://www.choigonyok.com/api/assets/34-11.png)

탄력적 ip주소는 보안 그룹이 있던 탭과 같은 위치에 있다. "탄력적 ip 주소 할당"을 누르고 모든 세팅을 DEFAULT로 둔 뒤 ip를 생성한다.

그리고 생성된 탄력적 ip 주소를 선택한 뒤 작업 -> 탄력적 ip 주소 연결을 눌러 인스턴스와 연결해준다.

![img](http://www.choigonyok.com/api/assets/34-12.png)

연결해준 뒤 인스턴스 탭에 가보면 세부정보에 아까는 없던 탄력적 ip 주소가 생성되어 있는 것을 확인할 수 있다. SSH를 통해 인스턴스에 접근할 때도 이 탄력적 ip 주소를 통해 접근할 수 있다.

탄력적 ip 주소를 생성하고 연결할 때도 주의해야할 부분이 있다. 만일 탄력적 ip 주소를 생성하기만 하고, 연결하지 않으면 프리티어 계정이더라도 비용이 부과된다. 

탄력적 ip를 생성해 잘 연결해서 쓰면 비용이 부과되지 않는다! 아마도 ip주소가 낭비되는 것을 막기위한 조치로 보인다.

처음 배포를 하는 개발자라면 배포과정에서의 오류로 인해 인스턴스를 생성했다 지웠다 하는 일들이 잦을텐데, 인스턴스를 지우기 전에 꼭 먼저 탄력적 ip 연결을 릴리즈한 후 탄력적 ip를 삭제하고 인스턴스를 지우기를 추천한다.

---

## EIP로 운영서버에 SSH접속하기

이제 SSH를 통해 인스턴스에 접속해보겠다. 나는 우선 맥OS를 사용하고 있다.

1. Terminal 실행

터미널은 응용프로그램에 있다. 찾기 어려우면 cmd+space로 Spotlight에 terminal을 검색하면 실행할 수 있다.

2. 명령어 입력

    ssh -i "<.pem key가 있는 디렉토리/pem key 이름>" <기본 사용자이름>@<탄력적 ip 주소>

이 명령어를 터미널에 치면 인스턴스로 접근할 수 있다. 명령어 예시를 들어보겠다.

인스턴스의 OS는 ubuntu이고, pem키는 로컬의 PEM 폴더 안에 들어있고 PEM키 이름은 myapp.pem 이며, 3번 과정에서 할당한 탄력적 ip 주소가 201.230.7.2라고 가정하자.

그럼 명령어는

        ssh -i "PEM/myapp.pem" ubuntu@201.230.7.2

이렇게 입력하면 된다. 기본 사용자이름이 ubuntu인 이유는 ubuntu OS에서는 기본 사용자 이름이 ubuntu로 지정되어있기 때문이다. 기본 사용자이름은 OS마다 다를 수 있으므로 찾아보고 입력해야한다.

이렇게 명령어를 입력하면 터미널과 SSH를 통해 인스턴스로 접속할 수 있게된다.

![img](http://www.choigonyok.com/api/assets/34-13.png)

---

## 리액트 배포 Configuration

이제 배포를 위한 인스턴스는 준비가 다 되었고, 프런트엔드를 배포해보자.

### 1. Git clone

우선 터미널로 접속한 인스턴스에서 git clone 명령어로 github 레포지토리에서 코드를 PULL 해온다.

        git clone  <레포지토리 주소>

레포지토리 주소는 깃허브에서 해당 레포지토리에 들어가면 

![img](http://www.choigonyok.com/api/assets/34-14.png)

우측 상단에 CODE라고 초록 창이 보일 것이다. 이를 클릭하면 

![img](http://www.choigonyok.com/api/assets/34-15.png)

이런 창이 나타나는데 HTTPS 주소를 복사해서 위 명령어의 <레포지토리 주소> 부분에 입력해주면 된다.

그리고 리액트를 위한 코드들을 실행하기 전에 우분투 패키지매니저를 업데이트해준다.

apt는 우분투에서 제공하는 패키지 매니저인데, 여러 패키지(소프트웨어, 설치파일 등)을 쉽게 설치하고 관리할 수 있게 해주는 툴이다. 이 APT 패키지매니저를 업데이트해줘야 최신 버전의 패키지들을 잘 다운받을 수 있다.

    sudo apt update
    sudo apt upgrade
    sudo apt autoremove

### 2. Node.js install

리액트에서 쓰던 npm을 사용하기 위해 node.js를 설치해준다.

    sudo apt install nodejs

### 3. npm install

    npm install

이 명령어를 통해서 git에서 clone해온 나의 코드에 필요한 의존성들을 설치해준다.

로컬에서 의존성을 설치해서 깃에 push하고 인스턴스에서 pull할 수도 있긴 하다. **깃허브는 최대 100MB의 크기까지만 지원하는데**, 의존성의 크기가 크면 오류가 생길 수도 있기 때문에 운영환경에서 새롭게 의존성을 설치하는 걸 추천한다.

### 4. 부족한 의존성 체크
   
    npm start
        
개발환경 실행을 우선 해서 의존성 관련 오류가 없는지 확인하고, 아직 설치되지 않은 의존성이 있다면 package.json에 미처 입력이 안되었다는 뜻이니 따로 install 해준다. (나의 경우엔 axios였다.)

### 5. 포트 정상 작동하는지 확인

npm start로 port도 정상 작동하는지 브라우저에서 접속해 확인해본다.

### 6. 확인되면 리액트 빌드파일 만들기

    npm run build
        
배포를 위해 소스파일을 빌드한다. 개발환경은 운영환경과는 다르게 잦은 수정보다는 빠른 속도와 안정성이 중요하다. 이것이 개발환경에서는 nginx를 안쓰지만 운영환경에서는 사용하는 이유이다.

빌드파일을 만들면 이후 설명하겠지만 nginx에서 브라우저의 요청에 따라 알아서 정적인 빌드파일을 브라우저에 제공해주게 될 것이다.

### 7. Nginx install
   
    sudo apt install nginx

그 기능을 해줄 nginx를 설치한다.

### 8. Netstat install

    sudo apt install net-tools

배포 이후에 개발환경과 운영환경의 차이로 인해 생기는 여러 에러들이 발생한다. 

이 에러들을 처리할 때 실행중인 빌드파일을 중지하고 오류를 해결한 후 재시작하게 되는데, 이전에 올라가 있던 프로그램이 아직 죽지 않아서 포트가 겹치는 에러가 발생한다.

이를 해결하려면 그 포트에서 실행되고 있는 프로그램을 kill 해야하는데,  netstat을 통해 kill할 수 있다.

### 9. Nginx run
   
    sudo systemctl start nginx

nginx와 관련된 몇 가지 명령어를 소개한다.

* nginx 상태 보기
  
    sudo systemctl status nginx

* 재시작하기

    sudo systemctl restart nginx

* 종료하기
        
    sudo systemctl stop nginx

### 10. Nginx Firewall

브라우저에서 nginx에 접근할 수 있도록 방화벽을 설정해줘야한다.

세 가지 옵션이 있다.

    Nginx Full – 전체 포트 열기
    Nginx HTTP – 80 포트 열기
    Nginx HTTPS – 443 포트 열기
    Nginx OPENSSH - 22 포트 열기

설정한 방화벽을 활성화하려면

    sudo ufw enable

이 명령어를 이용하면 된다. 위의 옵션을 적용하기 위해서

    sudo ufw allow "<옵션명>"

을 실행해주면 해당 옵션대로 방화벽 설정이 적용된다. 설정한 방화벽의 변경사항을 적용하기 위해서 nginx를 재시작해준다.

    sudo ufw reload

방화벽 상태를 확인하고 싶다면,

    sudo ufw status

이 명령어를 통해 현재 active 상태인지 아닌지를 체크할 수 있다.

팁으로 탄력적 ip 주소라고 해도 의미 없는 12자리의 숫자를 계속 외우는 건 쉽지 않은 일인데, 그렇다고 매번 aws에 접속해서 인스턴스 탭에 들어가 주소를 확인하긴 여간 귀찮은 일이 아니다. 그럴 때

    curl ifconfig.me

이 명령어를 터미널에 입력하면 ip주소를 확인할 수 있다!

---

## 리액트 배포

여기까지 문제없이 잘 실행했다면, 브라우저에 <탄력적 ip 주소:포트번호>를 입력하면 리액트가 잘 실행되어야한다. 물론 백엔드는 아직 배포하지 않아서 무언가 상호작용할 요소는 거의 없겠지만 말이다!

그래도 개발환경의 localhost 굴레에서 조금은 벗어나게 되었다.

이제 nginx에서 빌드파일 루트를 설정해줘야한다. 설정해주게 되면 포트번호 입력없이도 기본 HTTP 포트인 80번으로 접속했을 때 접속이 가능해지게 된다.

80번 포트는 기본 포트라 생략이 가능하기 때문에 그냥 브라우저에 ip주소만 입력하면 리액트 빌드파일이 실행될 수 있게 되는 것이다.

### 1. nginx root config
   
* 디폴트 config 삭제
 
    sudo rm /etc/nginx/sites-available/default
    sudo rm /etc/nginx/sites-enabled/default

nginx의 기본 config 파일들을 모두 삭제해준다. 새롭게 config 파일을 작성해줄 것이다.

* config file 생성

    cd /etc/nginx/sites-available/
    sudo touch <config파일 이름>.conf

이 경로로 이동해서 파일을 작성해주면 된다. 파일이름은 자유롭게 설정 가능하다.

* config에 vim모드로 입력

vim은 에디터인데, vim <파일명>을 입력하면 그 파일을 찾아서 vim모드로 열어주고, 없으면 파일을 생성해서 열어준다.
vim모드에서 작성은 i를 누르면 insert mode로 전환되어서 작성이 가능하다.

        server {
          listen 80;
          location / {
            root   /home/ubuntu/blog-project-frontend/build;
            index  index.html index.htm;
            try_files $uri $uri/ /index.html;
          }
        }

listen 80은 80번 포트에서 오는 요청을 듣겠다는 뜻이다.

location / 은 80번 포트의 / 경로, 즉 모든 경로에 대해 접근이 들어올 때를 지정하는 것이고, 그 안의 root는 80번 포트의 모든 경로로 접근이 들어올 때마다 저 디렉토리에서 정적 파일들을 서빙하겠다는 뜻이다.

리액트는 빌드파일을 생성하면 모든 데이터가 빌드 폴더 안에 들어가게 된다. 즉 빌드파일이 생성되는 경로를 적어주면 된다.

index는 정적파일 중에서도 nginx가 처음으로 읽어야할 파일이 무엇인지를 명시해준다. 나의 경우는 index.html, index.htm 으로 이름을 설정해두었다.

이렇게 설정한 config 파일은 nginx가 읽을 수 있는 위치로 이동시켜줘야한다.

    sudo ln -s /etc/nginx/sites-available/myapp.conf /etc/nginx/sites-enabled/myapp.conf

이동한 후에 적용될 수 있도록 nginx를 재시작해준다. 위에 적어두었던 reload command를 사용한다.

    sudo systemctl reload nginx

이제 설정이 모두 마무리되었고, 브라우저에 포트번호 입력 없이 ip주소만 입력해서 정상적으로 동작하는지 확인해본다.

만약 접속 시 500 상태코드 에러가 렌더링된다면 build파일까지 가는 경로의 권한문제일 수 있다.

    chmod 711 /home/ubuntu/blog-project-frontend

이 명령어를 통해 권한을 설정해준다.

---

## 문제

이렇게까지 하면 잘 접속이 되어야하는데, 우분투 서버에 exit한 이후에 다시 public ip로 ssh 접속을 시도하니까 접속이 되지 않는다.

인바운드 규칙에 22번 포트를 열어두지 않았나? 해서 확인해보니 그것도 아니다.

한참을 헤매다가 아래 참고 섹션의 링크에서 답을 찾았다.

방화벽 설정시 HTTPS와 HTTP만 설정해둔 것이 문제였다. ssh는 22번 포트를 통해 접속하는데, 방화벽이 ssh 접속을 막고있으니, 마치 열쇠를 집 안에 두고 집 문이 잠겨버린 꼴이 된 것이다. 

이 문제로 전체 인스턴스를 삭제 후 다시 config하는 과정을 겪었다.

인스턴스를 재생성하고 방화벽을 설정할 때, OPENSSH 설정도 해주니까 로그아웃했다가 다시 우분투에 ssh접속해도 접속 잘되는 걸 확인할 수 있었다.

---

## 참고

[문제 해결 사이트](https://velog.io/@johnyworld/ec2%EC%97%90-ssh-%EC%A0%91%EC%86%8D%EC%8B%9C-timeout-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0)

[AWS에서 http->https 리다이렉션 간단히 하는법](https://medium.com/@yangga0070/aws-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%84%9C-http-https-%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%EC%85%98-37c1039be0ab)
