# #2. 리액트 이미지 IMPORT
# project blog

---

## 개요

메인에서 게시글들을 보여주는 카드 컴포넌트에 썸네일 이미지를 삽입하고 싶었다. 리액트에서는 import를 통해 이미지 파일을 출력할 수 있다.

```JS
import img from "../Assets/Images/img.png";
```

이미지를 렌더링할 컴포넌트에 이미지 경로를 import 해주고, 정의한 객체(img)를 JSX 안에 넣으면 이미지 출력이 가능하다.

---

## 문제점

이 방식으로 게시글의 이미지를 출력하게 되면 몇 가지 문제가 생긴다.

* 새로운 썸네일을 import 하기위해 글을 쓸 때마다 코드를 수정해야한다.
* 글을 삭제할 때, 리소스가 낭비되지 않도록 import 했던 코드를 삭제해야한다.

### 모든 게시글마다 이미지를 import하는 하드코딩

개발환경에서야 VScode만 실행해서 잠깐 수정하면 되지만, 실제 배포를 하면 글을 쓰거나 지울 때마다 서버에 원격으로 접속해서 코드를 수정하고 다시 배포하는 복잡한 과정을 거쳐야한다.

### 동적으로 import

안타깝게도 리액트에서는 import를 동적으로 런타임에 실행할 수 있는 기능이 없다.

그럼 리액트에서 이미지를 동적으로 가져오려면 어떻게 해야할까?

---

## 방버

세 가지 방법이 있다.

### 1. 이미지 파일을 base64로 변환하기 

base64는 데이터를 바이너리 문자열로 변환하는 형식이다.

이미지의 각 픽셀 별 RGB 정보를 하나하나 다 읽어오는 로우레벨 방식이라고 할 수 있다. 그만큼 변환한 후의 데이터의 길이와 사이즈가 커지게 된다. 약 30%정도 크기가 증가한다고 한다. 파일의 사이즈 뿐만 아니라 base64를 인코딩/디코딩 하는데에도 리소스가 소모된다.

### 2. 이미지 파일을 클라이언트에서 동적으로 저장/출력하기 

이 방식은 이미지 파일을 주고받을 필요가 없어서 간단하긴 하지만 보안적으로 위험하기 때문에 서버-클라이언트 아키텍처의 장점을 살리지 못한다. 그리고 이미지의 동적 import 가 불가능한 문제는 해결되지 않는다.

### 3. **URL 을 통한 파일 업로드/다운로드**

리액트의 file import는 **컴파일 타임**에 이루어진다. STATIC 리소스를 가져오는 것과 동일하다. 이에 반해 url 방식은 url로 요청을 보낼 때 (런타임에) 동적으로 이미지를 가져오기 때문에 import 없이도 이미지 출력이 가능하다.

---

## URL

> URL(Uniform Resource Locator)은 리소스를 식별하기 위한 주소이다.

리소스(파일)를 식별하기 위해 Uniform Resource Indicator(URI)를 사용한다. 이 URI는 URN과 URL 두 종류가 있다.

URN은 이름(NAME)을 통해서 리소스를 식별하고, URL은 주소/위치(Locator)를 통해서 리소스를 식별한다. 우리가 웹 사이트를 접속할 때 흔하게 접하는 URL이 바로 이 URL이다.

클라이언트에서 URL로 파일 다운로드를 하려고 서버에 보내는 요청은 **GET 요청**이다. 요청만 한다고 데이터를 다 받을 수 있는 것은 아니고 요청받은 호스트가 요청에 대한 적절한 응답을 해주면 파일을 다운로드하거나, HTML을 렌더링받거나, RESTful API의 경우엔 원하는 데이터를 전송받을 수 있다.

---

## 구현

* 리액트에서 URL 요청
```js
<img className="postcard-image" alt="img" src="http://localhost:8080/Images/img.jpeg"/>
```

HTML에서 이미지 파일을 URL로 전달받기 위해서 img 태그의 src 속성을 이용한다. 리액트의 JSX에서도 동일하게 사용 가능하다.

src에 URL을 입력하면 이 JSX가 렌더링 될 때 호스트인 localhost의 8080번 포트에 /Images/img.jpeg 경로에 있는 파일을 GET 요청하게 되는 것이다.


* 서버에서 GET요청 응답 구현
```go
eg.GET("/Images/*", func (c *gin.Context){
    file, err := os.Open("src/Images/img.jpeg")
    if err != nil {
        http.Error(c.Writer, "Failed to open file", http.StatusInternalServerError)
        return
    }
    defer file.Close()
    _, err = io.Copy(c.Writer, file)
    if err != nil {
    http.Error(c.Writer, "Failed to send file", http.StatusInternalServerError)
    return
    }
})
```

서버에서 Images 경로로 GET 요청이 들어오면 

    os.Open(FILEPATH)
    
함수를 통해서 img.jpeg 파일에 대한 오브젝트를 생성하고, 

    io.Copy(c.Writer, file)

파일을 Writer 포인터에 write 하는 방식으로 구현했다.

이렇게 구현하게 되면 클라이언트-서버간에 통신을 하고 파일을 전달해줄 수 있다. 그러나 동적으로 클라이언트가 요청하는 파일을 선택해서 전달해줄 순 없다. 리액트 코드의 src 부분 역시 하드코딩 되어있기 때문이다.

해결방법으로는 URL의 **파라미터**를 통해서 동적으로 원하는 파일을 지정할 수 있다.

* 동적으로 수정하기
```go
eg.GET("/Images/:imgname", func (c *gin.Context){
        imgname := c.Param("imgname")
        file, err := os.Open("src/Images/"+imgname)
        ...
})
```

    c.Param("imgname")

핸들러에서 imgname이라는 파라미터를 Param 메서드로 받는다. 만약 클라이언트에서

    {HOST}/Images/1

이라는 경로로 요청이 들어오면 imgname은 Param 메서드를 통해 1이 되는 것이다. 이러면 서버는 매번 받는 파라미터에 따라 알맞은 파일을 클라이언트에 응답할 수 있다.

—--

## 업로드

> 다운로드는 알겠는데, 그럼 업로드는 어떻게 하지?

업로드는 첫 번째 프로젝트에서 이미 구현해본 적이 있다. 사용자가 이미지 파일을 multipart/form-data 형식으로 POST 요청을 보내면 서버에서는 전달받은 요청본문의 데이터를 디코딩하고, 이미지를 핸들링할 수 있다.
multipart/form-data 형식은 일반적인 plain/text 형식이 아니기 때문에 헤더를 통해서 content-type을 명시해줘야 오류없이 파일을 잘 전달받을 수 있다.

파일 업로드 기능이 구현될 admin page는 블로그 개발의 가장 마지막에 구현하려고 기획 중에 있다. 우선 대부분의 데이터는 하드코딩 된 더미데이터로 구현하고 나중에 리팩토링 하면서 동적으로 수정한 후에, 마지막으로 admin page를 구현할 것이다.

이번 블로그 프로젝트에서 BE/FE를 분리해서 개발하고 있긴하지만 결국 인스턴스 하나에 포트만 달리해서 배포하게 될텐데, 이번 프로젝트를 마무리하고 docker/container/k8s에 대해 공부해서 다음 프로젝트에는 FE/BE/DB를 각각 다른 인스턴스에 올리거나, 한 인스턴스에 올려도 각기 격리되는 가상화를 시도해봐야겠다.

마지막으로 이미지 다운로드를 구현하면서 새롭게 배운 것을 공유하고 글을 마무리 지으려고한다.

—

## 업로드, 다운로드에 대한 헷갈리는 개념

> 파일을 업로드하면 파일은 어디 숨어있다가 다운로드할 때 튀어나오는거지?

파일의 업/다운로드의 개념에 대해 잘못알고 있었다가 이번에 리액트로 파일 다운로드를 구현하면서 잘못된 지식을 바로잡게 되었다. 이전에 내가 잘못 알고있던 업/다운로드에 대한 개념은 다음과 같다.

    클라이언트(서버) —(업로드)—>(매개체)

> 
      
    (매개체)—(다운로드)—> 서버(클라이언트)

그 동안 이 개념을 가지고있어서, 파일 전송엔 매개체가 필요하다고 생각했고 그 매개체가 특정 웹브라우저인지, 아니면 어떤 회사에서 파일 전송을 위한 서버를 제공해주나? 하는 의문을 가지고있었다.

이 개념은 잘못된 개념이고, 일반적으로 업로드와 다운로드는 사용자 입장을 기준으로 정의되는 용어이다.

    업로드 : 클라이언트 —> 서버
<br>

    다운로드 : 서버 —> 클라이언트